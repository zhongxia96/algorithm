多重背包问题，其介于0-1背包和完全背包之间：有容积为V的背包，给定一些物品，每种物品包含体积w,价值v和数量k,求用该背包能装下的最大价值总量。

多重背包中，每种物品可选的数量不再为无穷或者1，而是介于其中的一个确定的数。与之前讨论的问题一样，我们可以将多重背包问题直接转化到0-1背包上去，即每种物品
均被视为k种不同的物品，对所有的物品求0-1背包，其时间复杂度为：
O（s*sum_{i=1}^{n}ki)

由此可见，降低每种物品的数量ki可以将会大大降低其复杂度，于是我们采用一种更为技巧性的拆分。将原数量为k的物品拆分为若干组，每组物品都看成一件物品，其价值
和重量为该组种所有物品的价值重量总和，每组物品包含的原物品个数分别为：1、2、4...k-2^c,其中c为使k-2^c+1的最大整数。

这种类似于二进制的拆分，不仅将物品数量大大降低，同时通过对这些若干个原物品组合得到新物品的不同组合，可以得到0到k之间的任意件物品的价值重量和，所以对所有
这些新物品做0-1背包，即可得到多重背包的解。

由于转化后的0-1背包物品数量大大降低，其时间复杂度也得到了较大优化，为 O（s*sum_{i=1}^{n}log(ki));

```
#include <iostream>
#include <algorithm>
#include <math.h>

using namespace std;

int p[505];
int h[505];
int dp[105];

int main(){
    int C;
    cin>>C;
    while(C--){
        int n,m;
        cin>>n>>m;
        int a,b,c;
        int num = 0;
        for(int i=1;i<=m;i++){
            cin>>a>>b>>c;
            int sum = 0;
            for(int j=0;j<=c;j++){
                if(sum+pow(2,j)<=c){
                    p[num] = a*pow(2,j);
                    h[num] = b*pow(2,j);
                    num++;
                    sum+=pow(2,j);
                }
                else if(sum==c)
                    break;
                else{
                    p[num] = a*(c-sum);
                    h[num] = b*(c-sum);
                    num++;
                    break;
                    }
            }
        }
        for(int i=0;i<=n;i++)
            dp[i] = 0;
        for(int i=1;i<=num;i++)
            for(int j=p[i];j<=n;j++){
                int a = dp[j];
                int b = dp[j-p[i]]+h[i];
                dp[j] = max(a, b);
            }
        cout<<dp[n]<<endl;
        
        
    }
    return 0;
}
```

多重背包的特征是每个物品可取的数量为一个确定的整数，我们通过对这个整数进行拆分，使若干物品组合成一个价值和体积均为这几个物品的和的最大的物品，同时通过
这些大物品的间的组合又可以组合出选择任意件物品所包含的体积和重量情况，通过这种拆分使最后进行0-1背包的物品数量大大减少，从而降低时间复杂度。
