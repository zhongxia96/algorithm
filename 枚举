枚举是最简单也是最直白的搜索方式，它以此尝试搜索空间中的所有解，测试其是否符合条件，若符合则输出答案，否则继续测试下一组解。

但是在使用枚举这种相对暴力的算法来进行解题时，我们对其时间复杂度要做特别的关注。我们对某一问题进行枚举的时候，必须保证其时间复杂度在题目时限可以接受的
范围。

下面给出一个样例（百鸡问题）：
用小于等于n元去买100只鸡，大鸡5元/只，小鸡3元/只，还有1/3元每只的一种小鸡，分别记为x只，y只，z只。编程求解x,y,z所有可能解。

```
#include <iostream>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        for(int x=0;x<=100;x++)
            for(int y=0;y<=100-x;y++){
                int z = 100-x-y;
                if(5*x*3+3*y*3+z<=n*3)  //为了避免精度损失，采取对不等式两端都乘3都策略
                    cout<<"x="<<x<<",y="<<y<<",z="<<z<<endl;
            }
    }
    return 0;
}
```

在复杂度允许的范围内，直白的枚举思路简单，代码清晰，所以在一些看似无法下手的题目面前，我们要换个角度，试着从更暴力的角度去思考。

这里讨论一下查找的几个要素：
（1）查找空间。在枚举问题中，所有可能成为答案的解组成了其查找空间。枚举过程即枚举查找空间中的每一个解。在枚举过程中，要做到不遗漏，不重复。
（2）查找目标。即查找到一组符合问题要求的解。为此，我们必须对枚举出来的每一个解进行相关判定。
（3）查找方式。与之前讨论过的查找方式相比，枚举的查找方式依旧比较原始，它简单的依次遍历所有的解，直到得到符合要求的解。
