利用递推解决问题，我们首先要确定几个规模较小的问题的答案。然后考虑如何由这几个规模较小的答案推出后面的答案。一旦有了递推规则和数列初始的几个值。
计算机程序就能帮助我们求解数列后面的所有数字，问题也得到了解决。

下面来看一道题目。

题目大意为：一名同学同时给N个网友每个人写了一封信，但是他竟然把所有的信都装错了信封！注意是全部装错，现在的问题是：一共有多少种可能的错误方式呢？

题解：我们容易得到规模较小时错装方式的数量。如当n为1时，数量为0；当n为2时，数量为1.按照n的取值顺序将所有的错装方式数量排列为一个序列，同样F[n]表示
序列里的第n个数值，同时代表n个信封的装错方式总数，我们确定该数列的递推关系。当n大于3时，考虑n封信全部装错的情况，将信封按顺序由1到n编号。在任意一种
装错方案中，假设n号信封里装的是k号信封的信，而n号信封里的信装在m号信封里。我们按照k和m的等值与否将总的装错方式分为两类。

若k不等于m,交换n号信封和m号信封的信后，n号信封装的恰好是对应的信，而m号信封错装的是k号信封的信，即除n号信封外，其余n-1封信封全部装错，其错装方式等于
F[n-1],又由于m的n-1个取值，这类的错装方式总数为（n-1)*F(n-1).也可以理解为在n-1个信封错装的F(n-1)种方式的基础上，将n号信封所装的信与n-1个信封中任意
一个信封（共有n-1个选择）所装的信做交换后，得到所有信封全部装错的方式数。

另一种情况，若k等于m,交换n号信封和m号信封的信后，n号信封和m号信封里装的恰是对应的信，这样除他们之外剩余的n-2个信封全部装错，其错装方式为F(n-2)，又由于
m的n-1取值，这类错装方式总数为（n-1)*F(n-2).也可以理解为，在n-2个信封全部错装的基础上，交换最后两个信封中的信（n号信封和1到n-1号信封中的任意一个，共
有n-1中选择），使所有的信封全部装错的方式数。

综上所述，F（n)=(n-1)*F(n-1)+(n-1)*F(n-2).这就是有名的错排公式。

```
#include<iostream>

#include<math.h>

using namespace std;
long long ans[23];

int main(){
    ans[1] = 0;
    ans[2] = 1;
    for(int i=3;i<=20;i++)
        ans[i] = (i-1)*ans[i-1] + (i-1) * ans[i-2];
    int n;
    while(cin >> n)
        cout<<ans[n]<<endl;
    return 0;
}
```
