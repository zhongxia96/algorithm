在一个已知序列中{a_{1},a_{2},...,a_{n}}中，取出若干数组成新的序列{a_{i1}, a_{i2}, ...,a_{im}},其中下标i1,i2,..,im保持递增，即新数列中的各个
数之间依旧保持原数列中的先后顺序，那么我们称新的序列{a_{i1}, a_{i2}, ...,a_{im}}为原序列的一个子序列。
若在子序列中，当下标ix>iy时，a_{ix}>a_{iy}，那么我们称这个子序列为原序列的一个递增子序列。最长递增子序列问题，就是在一个给定的原序列中，求得其最长
递增子序列的长度。

按照递推求解的思想，用F[i]代表递增子序列以ai结束时它的最长长度。当i较小时，我们容易直接得出其值，如F[1]=1.
那么如何由已经求得的F[i]值推得后面的值呢？假设，F（1）到F（x-1)的值都已经被确定，注意到，以ax结尾的递增子序列，除了长度为1的情况，其他情况中，ax都是
紧跟在一个由ai（i<x)组成的递增子序列之后.若ai小于ax,则说明ax可以跟在以ai结尾的递增子序列之后，形成一个新的递增子序列。又因为以ai结尾的递增子序列的
最长长度已经求得，那么在这种情况下，由以ai结尾的最长递增子序列再加上ax得到的新的序列，其长度也可以确定，取这些长度的最大值，我们即能得到F[x]的值。
特殊时，当没有ai(i<x)小于ax,那么以ax结尾的递增子序列最长长度为1.

总结一下，求最长递增子序列的递推公式为：
F[1]=1;
F[i]=max{1, F[j]+1|aj<ai&&j<i};

下面给出一个题目：
拦截导弹：导弹拦截系统的第一发炮弹能够达到任意高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，
请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按照来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。

题解：这就是一个最长递减子序列的问题。
F[1]=1;
F[i]=max{1, F[j]+1|aj>=ai&&j<i};  //注意等号！！！！

```
#include<iostream>

#include<math.h>

using namespace std;

int high[30];
int F[30];

int main(){
    int k;
    cin>>k;
    for(int i=1;i<=k;i++)
        cin>>high[i];
    F[1]=1;
    for(int i=2;i<=k;i++){
        F[i] = 1;
        for(int j=1;j<i;j++){
            if(high[j]>=high[i])
                F[i] = max(F[i], F[j]+1);
        }
    }
    int ans = 1;
    for(int i=1;i<=k;i++)
        if(F[i]>ans)
            ans = F[i];
    cout<<ans<<endl;
    return 0;
}
```

其时间复杂度是O（n*n),空间复杂度是O(n).

我们来回顾一下它的特点。
首先，将这个问题分割为许多子问题，每个子问题为确定以第i个数字结束的递增子序列的最长长度。
其次，这些子问题之间存在某种联系，以任意一个数字结束的递增子序列长度，与其排在该数字之前的所有比它小的元素结尾的最长递增子序列长度有关,且仅与其数字量
有关，而与其具体排列无关。
最后，规模较小的子问题是容易被我们确定的。
于是，我们像递推求解一样，一步步求得子问题的答案，进而由这些答案推出后续子问题的答案。
