图分为有向图和无向图

图有两种常用的数据结构：邻接矩阵和邻接链表

邻接矩阵使用一个二维数组来表示图的相关信息。
（1）在确定某对节点之间是否存在关系时，只需要访问二维数组中的相关单元即可，耗时较少；
（2）在有向图中也可以查找以任意节点为弧头或弧尾的所有所有弧；
（3）但是若需遍历与某节点相邻的所有节点，就需要依次遍历二维数组中某行的所有元素，判断其值后决定是否相邻，也就是说即使只有一个点与其相邻，我们也
需要消耗大量的时间来遍历该行中所有的数组单元；
（4）同时，用邻接矩阵来保存节点个数为n的图，其空间复杂度为O(n*n)；

邻接链表是一种链式存储结构，其为图的每个顶点建立一个单链表，第i个单链表中保存与节点Vi相邻的所有节点（无向图）或者所有以Vi为弧尾的弧指向的节点
(有向图）及其相关信息。
（1）邻接链表在遍历与某个节点相邻（无向图）或者以某个节点为弧尾的弧的弧头指向节点（有向图）时效率较高
（2）空间复杂度为O(n(点的数量)+e(边的数量))
（3）但是当其需要判断节点Vi与Vj间是否存在关系时就显得比较繁琐。它需要遍历Vi和Vj（无向图时任选一个）所有的邻接节点，才能判断他们之间是否存在关系
若应用中存在大量遍历邻接节点的操作而较少判断两个特定结点的关系时，选用邻接链表较为适宜。


对于每个结点的邻接链表，我们使用STL（标准模板库）中的标准模板std::vector
首先定义一个结构体，包括一些邻接节点和边权值，用来表示一条边。
struct Edge{
  int nextNode;   //下一节点编号
  int cost;       //该边的权重
  };
  
 接下来，为每个节点都建立一个单链表来保存与其相邻的边权值和节点的信息。使用vector来模拟这些单链表，利用如下语句为每个节点都建立一个vector对象
 
 vector<Edge> edge[N];   //节点数量为N
 
 为了使用vector,需要在源文件头部添加对应的头文件
 #include<vector>
 using namespace std;
 
 (1)清空链表
 for(int i=0;i<N;i++)
    edge[i].clear();
    
 (2)向链表中添加信息
 Edge tmp;
 tmp.nextNode = 3;
 tmp.cost = 38;
 edge[1].push_back(tmp);
 
 (3)当要查询某个节点的所有邻接信息时，需要对vector进行遍历
 for(int i=0;i<edge[2].size();i++){
    int nextNode = edge[2][i].nextNode;
    int cost = edge[2][i].cost;
    }
 对使用vector实现的邻接链表的访问非常类似于对二维数组的访问，但是其每行的长度是根据边的数量动态变化的
 
 (4)删除某个单链表中某些边的信息时
 edge[1].erase(edge[1].begin()+i, edge[1].begin()+i+1); 
 // vector.erase(vector.begin()+第一个要删除的元素编号,vector.begin()+最后一个要删除的元素编号+1)
