Floyd算法是一种计算最短路径长度的算法，又被称为佛洛伊德算法。

最短路径问题就是寻找图中某两个特定节点间的最短的路径长度。所谓图上的路径，即从图中一个起始节点到一个终止节点途中经过的所有节点序列，路径长度即
所经过的边权和。

Floyd算法使用邻接矩阵保存原图，edge[i][j]表示由节点i到节点j中间不经过任何节点时的最短距离，那么依次为中间允许经过的节点添加节点1，节点2...直到
节点N,当添加完这些节点后，从节点i到节点j允许经过的所有节点的最短路径长度就可以确定了，该长度即为原图上由节点i到节点j的最短路径长度。

for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            if(ans[i][k]==无穷||ans[k][j]==无穷) continue;
            if(ans[i][j]===无穷||ans[i][k]+ans[k][j]<ans[i][j])
                ans[i][j]=ans[i][k]+ans[k][j];
            }

（1）Floyd算法的时间复杂度是O(N^3),在大部分机试题的时间允许范围内，它要求被求解图的大小不大于200个节点；
（2）Floyd算法利用一个二维矩阵来进行相关运算，所以当图使用邻接矩阵表示时更为方便。若原图并非是由邻接矩阵给出时我们设法将其转换，注意当两个节点
间有多余一条边时，选择长度最小的边权值存入邻接矩阵；
（3）当Floyd算法完成后，图中所有节点之间的最短路都将被确定，所以其较适用于多个节点对之间的最短路径长度问题，即全源最短路问题；
