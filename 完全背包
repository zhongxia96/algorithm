完全背包问题：有一个容积为V的背包，同时有n个物品，每个物品均有各自的体积w和价值v，每个物品的数量均为无限个，求使用该背包最多能装的物品价值总和。

我们先按照0-1背包的思路试着求解该问题，设当前物品的体积为w,价值为v，考虑到背包中最多存放V/w件物品，我们可以将该物品拆成W/v件，即将当前可选数量为无限
的物品等价为V/w件体积为w，价值为v的不同物品。

对所有的物品均做如此拆分，然后对拆分后的所有物品做0-1背包即可得到答案。

但是，这样的拆分将使物品数量大大增加，其时间复杂度为：
O（V*sum_{i=1}^{n}V/wi)

可见，当V较大同时每个物体的体积较小时其复杂度会显著增大，故将该问题转化为0-1背包的做法较不可靠。
这里，我们提出一种时间复杂度为O（n*s)的做法，其使用经过空间优化的0-1背包所使用的一维数组，按照如下方法进行状态转移：
for(int i=1;I<n;i++){
    for(int j=list[i].w, j<=s;j++){
        dp[j]=max(dp[j], dp[j-list[i].w]+list[i].v);
        }
        }
注意到该代码片段与上文所讲的0-1背包相比，似乎只存在着对状态j的遍历顺序有所差异，这是有原因的。

在0-1背包中，之所以逆序循环更新状态是为了保证更新dp[j]时，dp[list[i].w]的状态尚未因为本次更新而发生改变，即等价于由dp[i-1][j-list[i].w]转移得到
dp[i][j]。

逆序循环，保证了更新dp[j]时，dp[j-list[i].w]是没有放入物品i时的数据（dp[i-1][j-list[i].w]),这是因为0-1背包中的物品至多被选择一次。

而在完全背包中，每个物品是可以被无限次选择，那么状态dp[i][j]恰好可以由可能已经放入物品i的状态dp[i][j-list[i].w]转移而来，故在这里将状态的遍历顺序
改为顺序，使更新状态dp[j]时，dp[j-list[i].w]时可能因为放入物品i而发生改变，从而达到目的。

题目：有一个储存罐，告知其空时的重量和当前重量，并给定一些钱币的价值和相应的重量，求储蓄罐里最少有多少现金。


```
#include <iostream>
#include <algorithm>
#include <math.h>

using namespace std;

int p[505];
int w[505];
int dp[10005];

int main(){
    int t;
    cin>>t;
    while(t--){
        int a,b;
        cin>>a>>b;
        int W = b-a;
        int n;
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>p[i]>>w[i];
        }
        for(int i=0;i<=W;i++)
            dp[i]=-1;
        dp[0]=0;
        for(int i=1;i<=n;i++)
            for(int j=0;j<=W;j++){
                if(w[i]<=j&&dp[j]!=-1&&dp[j-w[i]]!=-1){
                    dp[j]=min(dp[j], dp[j-w[i]]+p[i]);   //因为是最少，所以这里是min
                }
                else if(w[i]<=j&&dp[j-w[i]]!=-1)
                    dp[j]=dp[j-w[i]]+p[i];
            }
        
        cout<<dp[W]<<endl;
    }
    
    return 0;
}
```


