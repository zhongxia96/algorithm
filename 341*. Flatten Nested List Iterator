Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Example 1:

Input: [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, 
             the order of elements returned by next should be: [1,1,2,1,1].
Example 2:

Input: [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, 
             the order of elements returned by next should be: [1,4,6].
             
题解：
我写了一个超慢的程序...
就是一直判断第一个元素是不是一个整数，不是整数就把它展开

Runtime: 60 ms, faster than 6.10% of C++ online submissions for Flatten Nested List Iterator.
Memory Usage: 17.9 MB, less than 63.64% of C++ online submissions for Flatten Nested List Iterator.

/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class NestedIterator {
public:
    vector<NestedInteger> nested;
    
    NestedIterator(vector<NestedInteger> &nestedList) {
        nested = nestedList;
    }

    int next() {
        int ret = nested[0].getInteger();
        nested.erase(nested.begin(), nested.begin()+1);
        return ret;
    }

    bool hasNext() {
        if(nested.size()==0)
            return false;
        while(nested.size()>0&&nested[0].isInteger()==false){
            vector<NestedInteger> tmp = nested[0].getList();
            nested.erase(nested.begin(), nested.begin()+1);
            nested.insert(nested.begin(), tmp.begin(), tmp.end());
        }
        return nested.size()>0;
    }
};

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i(nestedList);
 * while (i.hasNext()) cout << i.next();
 */
 
 又写了一个先展开再取数的
 
Runtime: 24 ms, faster than 27.64% of C++ online submissions for Flatten Nested List Iterator.
Memory Usage: 22.2 MB, less than 6.06% of C++ online submissions for Flatten Nested List Iterator.

/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class NestedIterator {
public:
    vector<NestedInteger> nested;
    vector<int> numbers;
    int index;
    
    vector<int> getNumbers(NestedInteger nested){
        if(nested.isInteger())
            return vector<int>({nested.getInteger()});
        vector<int> res;
        for(auto item : nested.getList()){
            vector<int> tmp = getNumbers(item);
            res.insert(res.end(), tmp.begin(), tmp.end());
        }
        return res;   
    }
    
    NestedIterator(vector<NestedInteger> &nestedList) {
        for(auto item : nestedList){
            vector<int> tmp = getNumbers(item);
            numbers.insert(numbers.end(), tmp.begin(), tmp.end());
        }
        index = 0;
    }

    int next() {
        return numbers[index++];
    }

    bool hasNext() {
        return index<numbers.size();
    }
};

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i(nestedList);
 * while (i.hasNext()) cout << i.next();
 */
 
 看到标签是stack,用了栈优化之后
 Runtime: 20 ms, faster than 65.37% of C++ online submissions for Flatten Nested List Iterator.
Memory Usage: 19.4 MB, less than 18.18% of C++ online submissions for Flatten Nested List Iterator.

/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class NestedIterator {
public:
    
    stack<int> numbers;
  
    NestedIterator(vector<NestedInteger> &nestedList) {
        stack<NestedInteger> sta;
        for(auto item : nestedList){
            sta.push(item);
        }
        while(!sta.empty()){
            NestedInteger tmp = sta.top();
            sta.pop();
            if(tmp.isInteger())
                numbers.push(tmp.getInteger());
            else{
                for(auto item : tmp.getList())
                    sta.push(item);
            }
        }
    }

    int next() {
        int ans = numbers.top();
        numbers.pop();
        return ans;
    }

    bool hasNext() {
        return !numbers.empty();
    }
};

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i(nestedList);
 * while (i.hasNext()) cout << i.next();
 */


 又改了一下，好像占用空间少一点了
Runtime: 16 ms, faster than 91.96% of C++ online submissions for Flatten Nested List Iterator.
Memory Usage: 19.1 MB, less than 36.36% of C++ online submissions for Flatten Nested List Iterator.

 /**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * class NestedInteger {
 *   public:
 *     // Return true if this NestedInteger holds a single integer, rather than a nested list.
 *     bool isInteger() const;
 *
 *     // Return the single integer that this NestedInteger holds, if it holds a single integer
 *     // The result is undefined if this NestedInteger holds a nested list
 *     int getInteger() const;
 *
 *     // Return the nested list that this NestedInteger holds, if it holds a nested list
 *     // The result is undefined if this NestedInteger holds a single integer
 *     const vector<NestedInteger> &getList() const;
 * };
 */
class NestedIterator {
public:
    
    stack<NestedInteger> numbers;
  
    NestedIterator(vector<NestedInteger> &nestedList) {
        for(int i=nestedList.size()-1;i>=0;i--){
            numbers.push(nestedList[i]);
        }
    }

    int next() {
        int ans =  numbers.top().getInteger();
        numbers.pop();
        return ans;
    }

    bool hasNext() {
        while(!numbers.empty()){
            NestedInteger a = numbers.top();
            if(a.isInteger())
                return true;
            vector<NestedInteger> tmp = a.getList();
            numbers.pop();
            for(int i=tmp.size()-1;i>=0;i--)
                numbers.push(tmp[i]);
        }
        return numbers.size()>0;
    }
};

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i(nestedList);
 * while (i.hasNext()) cout << i.next();
 */
