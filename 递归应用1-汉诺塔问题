递归方式和递归出口是递归函数的两个重要的要素。

问题描述：一块铜板上有三根杆，最左边的杆上自上而下、由小到大的顺序串着由N个圆盘构成的塔。目的是将最左边杆上的全部盘全部移到右边的杆上，条件是一次只能
移动一个盘，不允许直接从最左边（右边）移到最右边（左边）（每次移动一定是移到中间杆或者从中间移出），且不允许大盘放在小盘上面。请问至少要移动多少次。

题解：与原始的汉诺塔问题不同，这里对圆盘的移动做了更多的限制，即每次只允许将圆盘移动到中间柱子上或者从中间柱子移出，而不允许由第一根柱子直接移动圆盘
到第三根柱子。

在这种情况下，考虑K个圆盘的移动情况。为了首先将初始时最底下、最大的圆盘移动到第三根柱子上，首先需要将其上的K-1个圆盘移动到第三根柱子上，而这恰好等价于
移动K-1个圆盘从第一根柱子到第三根柱子上，当这一移动完成之后，第一根柱子仅剩余最大的圆盘，第二根柱子为空，第三根柱子按顺序摆放着K-1个圆盘。我们将最大的
圆盘移动到此时没有任何圆盘的第二根柱子上，并再次将K-1个圆盘从第三根柱子上移动回第一根柱子上，此时仍需要移动K-1个圆盘从第一根柱子到第三根柱子所需的移动
次数（第一根柱子和第三根柱子等价），当这一移动完成之后将最大的圆盘移动到第三根柱子上，最后将K-1个圆盘从第一根柱子上移动到第三根柱子上。

若移动K个圆盘从第一根柱子到第三根柱子需要F[K]次移动，那么综上所述F[K]=3*F[k-1]+2

代码如下：
```
#include <iostream>
#include<queue>

using namespace std;

int F(int n){
    if(n==1)
        return 2;
    return 3*F(n-1)+2;
}

int main(){
    int n;
    while(cin>>n){
        cout<<F(n)<<endl;
    }
    return 0;
}
```
