有两个字符串S1和S2，求一个最长公共子串，即求字符串S3，它同时为S1和S2的子串，且要求它的长度最长，并确定这个长度。这个问题被我们称为最长公共子序列的问题。

与求最长递增子序列一样，我们首先将原问题分割成一些子问题，用dp[i][j]表示S1中前i个字符与S2中前j个字符分别组成的两个前缀字符串的最长公共子串长度。
显然的，当i,j较小时我们可以直接得出答案，如dp[0][j]必等于0.
那么，假设已经求得dp[i][j]（0=<i<x, 0=<j<y)的所有的值，考虑如何由这些值继而推得dp[x][y]，求得S1的前x个字符组成的前缀子串和S2中的前y个字符组成的前
缀子串的最长公共子序列长度。若S1[x]==S2[y]，即S1中第x个字符和S2中第y个字符相同，同时由于它们都是各自前缀子串中的最后一个字符，那么必存在一个最长公共
子串以S1[x]或S2[y]结尾，其他部分等价于S1中的前x-1个字符和S2中的前y-1个字符的最长公共子串。所以这个子串的长度必dp[x-1][y-1]又增加1，即
dp[x][y]=dp[x-1][y-1]+1.相反，若S1[x]!=S2[y],此时其最长公共子串长度为S1中前x-1个字符和S2中前y个字符的最长公共子串长度与S1中前x个字符和S2中前y个
字符的最长公共子串长度的较大者，即在这两种情况下得到的最长公共子串都不会因为其中一个字符串又增加来一个字符长度而发生改变。
综上所述，dp[x][y]=max(dp[x-1][y],dp[x][y-1]}

总结一下，最长公共子序列问题的递推条件：
dp[0][j](0=<j=<m)=0;
dp[i][0](0=<i=<n)=0;
dp[i][j]=dp[i-1][j-1]+1;(S1[i]==S2[j])
dp[i][j]=max{dp[i-1][j],dp[i][j-1]};(S1[1]!=S2[j])

由这样的递推公式和显而易见的初始值，我们能依次求得各dp[i][j]的值，最终dp[n][m]中保存的值即为两个原始字符串的最长公共子序列的长度。

```
#include<iostream>
#include<string.h>
#include<string>
#include<math.h>

using namespace std;

int dp[105][105];

int main(){
    string str1, str2;
    cin>>str1>>str2;
    int len1 = str1.length();
    int len2 = str2.length();
    for(int i=0;i<len1;i++)
        dp[i][0]=0;
    for(int j=0;j<len2;j++)
        dp[0][j]=0;
    for(int i=1;i<=len1;i++)
        for(int j=1;j<=len2;j++){
            if(str1[i-1]==str2[j-1])
                dp[i][j] = dp[i-1][j-1]+1;
            else
                dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
        }
    cout<<dp[len1][len2]<<endl;
    return 0;
}
```

其时空复杂度都是O（L1*L2），其中L1和L2分别为两个字符串的长度。

